<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Pickleball League ‚Äî 4 Courts (Offline)</title>
<style>
  :root{ --pad:12px; --gap:12px; --radius:12px; }
  html,body{margin:0;padding:0;font-family:-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Inter, Arial, sans-serif;background:#f7f7fb;color:#111}
  header{position:sticky;top:0;z-index:5;display:flex;flex-wrap:wrap;gap:8px;align-items:center;padding:10px 14px;background:#fff;border-bottom:1px solid #ececf3}
  header h1{font-size:18px;margin:0 8px 0 0;display:flex;align-items:center;gap:6px}
  #tournamentNameDisplay{font-size:14px;color:#555;font-weight:600}
  .tournament-controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .tournament-controls label{font-size:12px;color:#666}
  .tournament-controls select{padding:6px 8px;border:1px solid #dcdceb;border-radius:8px;font:inherit}
  .pill{background:#f1f3ff;border:1px solid #e0e5ff;border-radius:999px;padding:6px 10px;font-size:12px}
  main{display:grid;grid-template-columns:360px 1fr;gap:var(--gap);padding:var(--pad)}
  @media (max-width: 1000px){ main{grid-template-columns:1fr} }
  .leftcol{grid-column: 1 / 2}
  .rightcol{grid-column: 2 / 3}
  .span-all{grid-column: 1 / -1}
  .card{background:#fff;border:1px solid #e7e7f0;border-radius:var(--radius);box-shadow:0 .5px 0 rgba(0,0,0,.04)}
  .card h2{margin:0;padding:12px 14px;border-bottom:1px solid #efeff6;font-size:16px}
  .section{padding:12px 14px;display:flex;flex-direction:column;gap:10px}
  .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
  input,button,select{font:inherit}
  input[type="text"], input[type="number"]{padding:8px 10px;border:1px solid #dcdceb;border-radius:10px;min-width:0}
  input[type="text"]{flex:1}
  .btn{border:1px solid #d2d2e6;background:#fff;border-radius:10px;padding:8px 10px;cursor:pointer}
  .btn.primary{background:#155ee7;border-color:#1352c6;color:#fff}
  .btn.warn{background:#fee;border-color:#f6caca}
  .muted{color:#666;font-size:12px}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace}
  .list{display:flex;flex-direction:column;gap:6px}
  .player{display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border:1px dashed #e6e6f2;border-radius:10px;background:#fafbff}
  .tag{font-size:12px;background:#eef3ff;border:1px solid #dfe7ff;border-radius:999px;padding:2px 8px}
  .tag.green{background:#e9fbef;border-color:#c9f0d5}
  .right{margin-left:auto}
  .courts{display:grid;grid-template-columns:repeat(2, minmax(280px,1fr));gap:12px;padding:12px}
  @media (max-width: 800px){ .courts{grid-template-columns:1fr} }
  .court{border:1px solid #e7e7f0;border-radius:14px;background:#fff;display:flex;flex-direction:column}
  .court header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #efeff6;background:linear-gradient(#fff,#fafafe)}
  .court .body{padding:12px;display:flex;flex-direction:column;gap:8px}
  .teams{display:grid;grid-template-columns:1fr 28px 1fr;gap:8px;align-items:center}
  .team{display:flex;flex-direction:column;gap:6px}
  .slot{padding:8px 10px;border:1px solid #e7e7f2;border-radius:10px;background:#f8faff;display:flex;justify-content:space-between}
  .vs{font-weight:700;text-align:center}
  .progress{height:10px;background:#eef1ff;border-radius:999px;overflow:hidden;border:1px solid #e1e6ff}
  .bar{height:100%;background:#155ee7;width:0%}
  .leaderboard{padding:12px}
  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid #eee;padding:8px 6px;text-align:left;vertical-align:top}
  th{font-weight:600;background:#fafbff}
  .nowrap{white-space:nowrap}
  .chips{display:flex;gap:6px;flex-wrap:wrap}
  .chip{font-size:12px;padding:4px 8px;border-radius:999px;border:1px solid #e0e0ee;background:#f7f7ff;cursor:pointer}
  .chip.active{background:#155ee7;color:#fff;border-color:#155ee7}
  .chip.leader-secondary{background:#e6fff5;border-color:#b8f3d9;color:#0b6845}
  #leaderHighlights .chip,#leaderboardHighlights .chip{cursor:default}
  tr.points-leader{background:#fff6db;}
  tr.points-leader td{font-weight:600;}
  tr.pct-leader{background:#e8fff8;}
  tr.points-leader.pct-leader{background:#fff2d9;}
</style>
</head>
<body>
<header>
  <h1>Pickleball League <span id="tournamentNameDisplay"></span></h1>
  <div class="tournament-controls">
    <label for="tournamentSelect">Tournament</label>
    <select id="tournamentSelect"></select>
    <button class="btn" id="addTournamentBtn" type="button">Add Tournament</button>
    <button class="btn warn" id="removeTournamentBtn" type="button">Remove</button>
  </div>
  <span class="pill">Offline ‚Ä¢ Cookies (localStorage fallback)</span>
  <span class="pill">4 Courts</span>
  <span class="pill">Smart Points: Court + Opponent + Margin</span>
  <span class="pill" style="background:#fff3cd;border-color:#ffeaa7;color:#856404;" title="Use at your own risk. No warranty or liability assumed.">‚ö†Ô∏è Use at Your Own Risk</span>
</header>

<main>
  <!-- Left sidebar: Players & League Settings (controls only) -->
  <section class="card leftcol" id="playersSettingsCard">
    <h2>Players & League Settings</h2>
    <div class="section">
      <div class="row">
        <input id="name" type="text" placeholder="Player name">
        <input id="rating" type="number" placeholder="DUPR rating (e.g., 4.500)" step="0.001" min="2.000" max="8.000">
        <button class="btn primary" id="addPlayerBtn">Add Player</button>
        <button class="btn" id="addRandomBtn" title="Add a random player for testing">Add Random Player</button>
        <button class="btn" id="addRandom16Btn" title="Add sixteen random players for a full 4-court tournament">Add 16 Random</button>
      </div>
      <div class="row muted">
        <strong>DUPR Ratings:</strong> 2.000-8.000 (3 decimal places). <strong>Fair Seed Courts:</strong> Balanced teams across skill tiers. <strong>Gradual Start:</strong> Top 8 players start, others join later.
      </div>
      <div class="row">
        <label class="muted">League match limit:</label>
        <input id="matchLimit" type="number" min="1" step="1" placeholder="e.g., 20" style="width:110px">
        <button class="btn" id="applyLimitBtn">Apply</button>
        <span class="right muted">Matches played: <span id="played" class="mono">0</span>/<span id="limit" class="mono">‚Äî</span></span>
      </div>
      <div class="row">
        <label class="muted">Scoring System:</label>
        <select id="scoringSystem" style="width:200px">
          <option value="simple">Simple (Win +1, Loss -1)</option>
          <option value="court">Court Weighted (Court 1=1 pt ‚Ä¶ Court 4=4 pts)</option>
          <option value="smart">Smart Points (Court + Opponent + Margin)</option>
        </select>
        <span class="muted" id="scoringExplanation" style="font-size:11px;margin-left:8px;">
          Simple: Basic win/loss points. Court Weighted: Courts 1-4 award 1-4 pts for wins, no loss penalty. Smart: Considers court, opponent strength, and margin of victory.
        </span>
      </div>
      <div class="row" style="gap:8px;flex-wrap:wrap">
        <button class="btn" id="seedBtn" title="Balanced teams across skill tiers. Best for 8-16 players with mixed skill levels. Prevents unfair advantages while maintaining competitive balance.">Fair Seed Courts</button>
        <button class="btn" id="gradualSeedBtn" title="Start with top 8 players on highest courts, others join as players are eliminated. Best for 16+ players or when you want to avoid overwhelming the system initially.">Gradual Start</button>
        <button class="btn" id="classicSeedBtn" title="Original seeding: Top 4 on Court 4, next 4 on Court 3, etc. Simple but may create unfair advantages with new scoring systems.">Classic Seed</button>
        <button class="btn" id="shufflePairsBtn" title="Randomize team pairings within each court while keeping court assignments. Good for mixing up established partnerships.">Shuffle Pairs</button>
        <button class="btn" id="newLeagueBtn">New League (reset points & matches)</button>
        <button class="btn warn" id="resetBtn" title="Clear all saved data">Reset App</button>
        <button class="btn" id="exportBtn">Export</button>
        <label class="btn" for="importFile">Import</label>
        <input id="importFile" type="file" accept="application/json" style="display:none">
      </div>
      <div class="progress"><div id="bar" class="bar"></div></div>
    </div>
  </section>

  <!-- Right column: tournament live views -->
  <section class="card rightcol">
    <h2>Courts</h2>
    <div class="courts" id="courts"></div>
    <div class="section">
      <div class="row" style="justify-content:center;margin-top:15px;">
        <button class="btn primary" id="submitRoundBtn" style="font-size:16px;padding:12px 24px;">
          Submit Round
        </button>
      </div>
      <div class="muted" style="text-align:center;margin-top:8px;">
        Enter scores for all courts, then submit the entire round. Players will move to new courts after all matches are complete.
      </div>
    </div>
  </section>

  <section class="card rightcol" id="leaderboardCard" style="display:none">
    <h2>Leaderboard</h2>
    <div class="leaderboard">
      <table id="leaderboardTable">
        <thead><tr><th>#</th><th>Player</th><th>Points</th><th>DUPR</th></tr></thead>
        <tbody></tbody>
      </table>
      <div id="leaderboardHighlights" class="chips" style="margin-top:12px;"></div>
    </div>
  </section>

  <section class="card rightcol">
    <h2>Summary (Wins/Losses, Points%)</h2>
    <div class="section" style="overflow:auto">
      <div id="leaderHighlights" class="chips" style="margin-bottom:8px;"></div>
      <table id="summaryTable">
        <thead><tr><th>#</th><th>Player</th><th>Wins</th><th>Losses</th><th>Points %</th><th>Points</th></tr></thead>
        <tbody></tbody>
      </table>
      <div class="muted" style="margin-top:8px;font-size:11px;" id="percentageExplanation">
        Points % = Points Scored √∑ Total Points in All Games
      </div>
    </div>
  </section>

  <section class="card rightcol">
    <h2 style="display:flex;justify-content:space-between;align-items:center;cursor:pointer;" onclick="toggleHelp()">
      Help & Guide
      <span id="helpToggle" style="font-size:12px;color:#666;">‚ñº</span>
    </h2>
    <div class="section" id="helpContent" style="display:none;">
      <div style="margin-bottom:20px;">
        <h3 style="margin:0 0 10px 0;font-size:14px;color:#155ee7;">üéØ Scoring Systems</h3>
        <div style="margin-bottom:15px;padding:10px;background:#f8faff;border-radius:8px;border-left:3px solid #155ee7;">
          <strong>Simple Scoring:</strong> Win +1, Loss -1. Perfect for casual leagues. Easy to understand and track. No court difficulty consideration.
        </div>
        <div style="margin-bottom:15px;padding:10px;background:#f8faff;border-radius:8px;border-left:3px solid #155ee7;">
          <strong>Court Weighted:</strong> Higher courts give more points. Court 1=1 pt, Court 2=2 pts, Court 3=3 pts, Court 4=4 pts. Losses do not deduct points.
        </div>
        <div style="margin-bottom:15px;padding:10px;background:#f8faff;border-radius:8px;border-left:3px solid #155ee7;">
          <strong>Smart Points:</strong> Most sophisticated system. Considers court difficulty, opponent strength, and margin of victory. Base 10 points + bonuses.
        </div>
      </div>
      
      <div style="margin-bottom:20px;">
        <h3 style="margin:0 0 10px 0;font-size:14px;color:#155ee7;">üå± Seeding Methods</h3>
        <div style="margin-bottom:15px;padding:10px;background:#f0f8ff;border-radius:8px;border-left:3px solid #155ee7;">
          <strong>Fair Seed Courts (Recommended):</strong><br>
          ‚Ä¢ Adapts to any group size (1-20+ players)<br>
          ‚Ä¢ 1-4 players: All on Court 4<br>
          ‚Ä¢ 5-8 players: Split across Courts 3-4<br>
          ‚Ä¢ 9-12 players: Use Courts 2-4<br>
          ‚Ä¢ 13+ players: Use all 4 courts<br>
          ‚Ä¢ Balanced teams within each court
        </div>
        <div style="margin-bottom:15px;padding:10px;background:#f0f8ff;border-radius:8px;border-left:3px solid #155ee7;">
          <strong>Gradual Start:</strong><br>
          ‚Ä¢ Starts with top 8 players on highest courts<br>
          ‚Ä¢ Others join as players are eliminated<br>
          ‚Ä¢ Prevents system overwhelm with large groups<br>
          ‚Ä¢ Perfect for 16+ player tournaments
        </div>
        <div style="margin-bottom:15px;padding:10px;background:#f0f8ff;border-radius:8px;border-left:3px solid #155ee7;">
          <strong>Classic Seed:</strong><br>
          ‚Ä¢ Original simple seeding method<br>
          ‚Ä¢ Top 4 on Court 4, next 4 on Court 3, etc.<br>
          ‚Ä¢ Familiar to existing users<br>
          ‚Ä¢ Good for consistent skill levels
        </div>
      </div>
      
      <div style="margin-bottom:20px;">
        <h3 style="margin:0 0 10px 0;font-size:14px;color:#155ee7;">üìä How to Use</h3>
        <div style="padding:10px;background:#f9f9f9;border-radius:8px;font-size:12px;line-height:1.4;">
          <strong>Step 1:</strong> Add players with DUPR ratings (2.000-8.000, 3 decimal places)<br>
          <strong>Step 2:</strong> Select your preferred scoring system<br>
          <strong>Step 3:</strong> Choose a seeding method that fits your group<br>
          <strong>Step 4:</strong> Set match limit and start playing!<br>
          <strong>Step 5:</strong> Enter scores and watch rankings update automatically
        </div>
      </div>
      
      <div style="margin-bottom:20px;">
        <h3 style="margin:0 0 10px 0;font-size:14px;color:#155ee7;">üí° Tips & Recommendations</h3>
        <div style="padding:10px;background:#fff8f0;border-radius:8px;font-size:12px;line-height:1.4;">
          <strong>For Beginners:</strong> Use Simple scoring + Classic seed<br>
          <strong>For Mixed Skill:</strong> Use Court Weighted + Fair seed<br>
          <strong>For Competitive:</strong> Use Smart Points + Fair seed<br>
          <strong>For Large Groups:</strong> Use any scoring + Gradual start<br>
          <strong>DUPR Ratings:</strong> 6.000+ Elite, 4.500-5.999 Advanced, 3.000-4.499 Intermediate, 2.000-2.999 Beginner
        </div>
      </div>
    </div>
  </section>

  <section class="card rightcol">
    <h2>Match History</h2>
    <div class="section">
      <div class="chips">
        <span class="chip active" data-filter="all">All</span>
        <span class="chip" data-filter="court1">Court 1</span>
        <span class="chip" data-filter="court2">Court 2</span>
        <span class="chip" data-filter="court3">Court 3</span>
        <span class="chip" data-filter="court4">Court 4</span>
        <select id="playerFilter">
          <option value="">Filter by player‚Ä¶</option>
        </select>
        <button class="btn" id="clearHistoryBtn" title="Remove all saved history">Clear History</button>
      </div>
      <div style="overflow:auto">
        <table id="historyTable">
          <thead>
            <tr>
              <th class="nowrap">When</th>
              <th>Court</th>
              <th>Team A</th>
              <th>Team B</th>
              <th>Score</th>
              <th>Total</th>
              <th>Winner</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </section>

  <!-- Bottom full-width: Player List (with count) -->
  <section class="card span-all" id="playersListCard">
    <h2>Players (<span id="playerCount">0</span>)</h2>
    <div class="section">
      <div id="playerList" class="list"></div>
    </div>
  </section>

  <!-- Legal Disclaimer Section -->
  <section class="card span-all" style="background:#fff3cd;border-color:#ffeaa7;">
    <h2 style="color:#856404;">‚ö†Ô∏è Legal Disclaimer</h2>
    <div class="section" style="color:#856404;font-size:12px;line-height:1.4;">
      <strong>USE AT YOUR OWN RISK</strong><br><br>
      This software is provided "as is" without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose, and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages, or other liability, whether in an action of contract, tort, or otherwise, arising from, out of, or in connection with the software or the use or other dealings in the software.<br><br>
      The user assumes all responsibility and liability for the use of this application. The developers make no guarantees about the accuracy, reliability, or suitability of this software for any particular purpose. Use of this application is entirely at your own risk.
    </div>
  </section>
</main>

<script>
/* ---------- Storage ---------- */
const COOKIE_NAME = "pb_league_state";
const COOKIE_MAX_AGE_DAYS = 365;

function setCookie(name, value, days){
  try{
    const d = new Date();
    d.setTime(d.getTime() + (days*24*60*60*1000));
    const expires = "expires="+ d.toUTCString();
    document.cookie = name + "=" + encodeURIComponent(value) + ";" + expires + ";path=/;SameSite=Lax";
  }catch(e){}
}
function getCookie(name){
  const cname = name + "=";
  const parts = document.cookie.split(";");
  for(let c of parts){
    c = c.trim();
    if(c.indexOf(cname) === 0) return decodeURIComponent(c.substring(cname.length));
  }
  return null;
}
function hasCookieSupport(){
  try{
    setCookie("__t","1",1);
    const v = getCookie("__t");
    setCookie("__t","", -1);
    return v === "1";
  }catch(e){ return false; }
}
const Storage = (function(){
  const cookiesOk = hasCookieSupport();
  return {
    save(state){
      const json = JSON.stringify(state);
      try{
        if(cookiesOk){ setCookie(COOKIE_NAME, json, COOKIE_MAX_AGE_DAYS); }
        else { localStorage.setItem(COOKIE_NAME, json); }
      }catch(e){ alert("Save failed: "+e.message); }
    },
    load(){
      let raw = getCookie(COOKIE_NAME);
      if(!raw){ raw = localStorage.getItem(COOKIE_NAME); }
      if(!raw) return null;
      try{ return JSON.parse(raw); }catch(e){ return null; }
    },
    clear(){
      setCookie(COOKIE_NAME, "", -1);
      try{ localStorage.removeItem(COOKIE_NAME); }catch(e){}
    }
  };
})();

/* ---------- State ---------- */
function createDefaultState(){
  return {
    tournaments: [],
    activeTournamentId: null,
    playerCounter: 1,
    tournamentCounter: 1
  };
}
function createDefaultTournament(overrides = {}){
  return {
    id: overrides.id ?? null,
    name: overrides.name ?? "Tournament",
    players: Array.isArray(overrides.players) ? overrides.players : [],
    courts: Array.isArray(overrides.courts) ? overrides.courts : [[],[],[],[]],
    matchesPlayed: Number(overrides.matchesPlayed) || 0,
    matchLimit: overrides.matchLimit ?? null,
    matches: Array.isArray(overrides.matches) ? overrides.matches : [],
    tournamentStarted: Boolean(overrides.tournamentStarted),
    lastPartners: (overrides.lastPartners && typeof overrides.lastPartners === "object") ? overrides.lastPartners : {},
    scoringSystem: overrides.scoringSystem ?? "court"
  };
}
let state = createDefaultState();

/* ---------- Helpers ---------- */
const $ = (id)=>document.getElementById(id);
const clone = (x)=>JSON.parse(JSON.stringify(x));
const COURT_MULTIPLIERS = [1, 2, 3, 4];
const SMART_COURT_WEIGHTS = [0.5, 0.75, 1.0, 1.5];

function generateTournamentId(){
  if(!Number.isFinite(state.tournamentCounter) || state.tournamentCounter <= 0){
    state.tournamentCounter = 1;
  }
  return state.tournamentCounter++;
}
function generatePlayerId(){
  if(!Number.isFinite(state.playerCounter) || state.playerCounter <= 0){
    state.playerCounter = 1;
  }
  return state.playerCounter++;
}
function generateTournamentName(){
  const existing = new Set((state.tournaments || []).map(t=>t.name));
  let index = (state.tournaments?.length || 0) + 1;
  let candidate = `Tournament ${index}`;
  while(existing.has(candidate)){
    index += 1;
    candidate = `Tournament ${index}`;
  }
  return candidate;
}

function normalizeTournament(raw){
  const tournament = createDefaultTournament();
  if(!raw || typeof raw !== "object") return tournament;

  if(Number.isFinite(Number(raw.id))){
    tournament.id = Number(raw.id);
  }
  if(typeof raw.name === "string" && raw.name.trim()){
    tournament.name = raw.name.trim();
  }
  if(typeof raw.scoringSystem === "string" && raw.scoringSystem.trim()){
    tournament.scoringSystem = raw.scoringSystem.trim();
  }

  const players = Array.isArray(raw.players) ? raw.players.map(player=>{
    if(!player || typeof player !== "object") return null;
    const id = Number(player.id ?? player.playerId);
    if(!Number.isFinite(id) || id <= 0) return null;
    const name = String(player.name ?? `Player ${id}`).trim() || `Player ${id}`;
    const seedNum = Number(player.seed);
    const seed = Number.isFinite(seedNum) ? Math.max(2.000, Math.min(8.000, Math.round(seedNum * 1000) / 1000)) : 4.500;
    const pointsNum = Number(player.points);
    const points = Number.isFinite(pointsNum) ? Math.max(0, Math.round(pointsNum * 1000) / 1000) : 0;
    return {id, name, seed, points};
  }).filter(Boolean) : [];
  tournament.players = players;
  const playerIds = new Set(players.map(p=>p.id));

  const ensurePlayerIds = (team)=>{
    if(!Array.isArray(team)) return [];
    return team.map(id=>Number(id)).filter(id=>playerIds.has(id));
  };

  if(Array.isArray(raw.courts)){
    tournament.courts = raw.courts.slice(0,4).map(court=>ensurePlayerIds(court));
  }
  while(tournament.courts.length < 4){
    tournament.courts.push([]);
  }
  tournament.courts = tournament.courts.slice(0,4);

  const matches = Array.isArray(raw.matches) ? raw.matches.map(match=>{
    if(!match || typeof match !== "object") return null;
    const ts = Number(match.ts);
    const court = Number(match.court);
    const winner = match.winner === "B" ? "B" : "A";
    const scoreA = Number(match.scoreA);
    const scoreB = Number(match.scoreB);
    const A = ensurePlayerIds(match.A);
    const B = ensurePlayerIds(match.B);
    const system = typeof match.system === "string" ? match.system : undefined;
    let awards = null;
    if(match.awards && typeof match.awards === "object"){
      awards = {};
      Object.entries(match.awards).forEach(([pid,val])=>{
        const id = Number(pid);
        const num = Number(val);
        if(playerIds.has(id) && Number.isFinite(num)){
          awards[id] = Math.round(num * 1000) / 1000;
        }
      });
      if(Object.keys(awards).length === 0) awards = null;
    }
    return {
      ts: Number.isFinite(ts) ? ts : Date.now(),
      court: Number.isFinite(court) && court >=1 && court <=4 ? court : 1,
      winner,
      scoreA: Number.isFinite(scoreA) ? scoreA : 0,
      scoreB: Number.isFinite(scoreB) ? scoreB : 0,
      A,
      B,
      system,
      awards
    };
  }).filter(Boolean) : [];
  tournament.matches = matches;

  const limitNum = Number(raw.matchLimit);
  tournament.matchLimit = Number.isFinite(limitNum) && limitNum > 0 ? Math.round(limitNum) : null;

  const playedNum = Number(raw.matchesPlayed);
  tournament.matchesPlayed = Number.isFinite(playedNum) && playedNum >= 0 ? Math.round(playedNum) : matches.length;

  tournament.tournamentStarted = Boolean(raw.tournamentStarted);

  const partners = {};
  if(raw.lastPartners && typeof raw.lastPartners === "object"){
    Object.entries(raw.lastPartners).forEach(([pid,val])=>{
      const id = Number(pid);
      if(!playerIds.has(id)) return;
      const partnerId = Number(val);
      partners[id] = playerIds.has(partnerId) ? partnerId : null;
    });
  }
  tournament.lastPartners = partners;

  return tournament;
}

function normalizeStateStructure(raw){
  const normalized = createDefaultState();
  if(!raw || typeof raw !== "object") return normalized;

  if(Array.isArray(raw.tournaments)){
    normalized.tournaments = raw.tournaments.map(t=>normalizeTournament(t)).filter(Boolean);
    const activeId = Number(raw.activeTournamentId);
    normalized.activeTournamentId = Number.isFinite(activeId) && activeId > 0 ? activeId : null;
    const playerCounter = Number(raw.playerCounter);
    if(Number.isFinite(playerCounter) && playerCounter > 0){
      normalized.playerCounter = Math.floor(playerCounter);
    }
    const tournamentCounter = Number(raw.tournamentCounter);
    if(Number.isFinite(tournamentCounter) && tournamentCounter > 0){
      normalized.tournamentCounter = Math.floor(tournamentCounter);
    }
  } else {
    const single = normalizeTournament(raw);
    if(!Number.isFinite(single.id) || single.id <= 0){
      single.id = 1;
    }
    normalized.tournaments.push(single);
    normalized.activeTournamentId = single.id;
  }

  if(normalized.tournaments.length === 0){
    const fallback = createDefaultTournament({id: 1, name: "Tournament 1"});
    normalized.tournaments.push(fallback);
    normalized.activeTournamentId = fallback.id;
  }

  const usedIds = new Set();
  let maxTournamentId = 0;
  normalized.tournaments.forEach((t, index)=>{
    if(!Number.isFinite(t.id) || t.id <= 0 || usedIds.has(t.id)){
      maxTournamentId = Math.max(maxTournamentId, 0) + 1;
      t.id = maxTournamentId;
    }
    usedIds.add(t.id);
    maxTournamentId = Math.max(maxTournamentId, t.id);
    if(!t.name || !t.name.trim()){
      t.name = `Tournament ${index + 1}`;
    }
    if(!t.scoringSystem){
      t.scoringSystem = "court";
    }
    while(t.courts.length < 4){
      t.courts.push([]);
    }
    t.courts = t.courts.slice(0,4).map(list=>{
      return Array.isArray(list) ? list.map(id=>Number(id)).filter(id=>t.players.some(p=>p.id===id)) : [];
    });
    const playerIds = new Set(t.players.map(p=>p.id));
    const cleanedPartners = {};
    Object.entries(t.lastPartners || {}).forEach(([pid,val])=>{
      const id = Number(pid);
      if(!playerIds.has(id)) return;
      const partnerId = Number(val);
      cleanedPartners[id] = playerIds.has(partnerId) ? partnerId : null;
    });
    t.lastPartners = cleanedPartners;
  });
  normalized.tournamentCounter = Math.max(normalized.tournamentCounter, maxTournamentId + 1);

  let maxPlayerId = 0;
  normalized.tournaments.forEach(t=>{
    t.players.forEach(p=>{
      if(!Number.isFinite(p.id) || p.id <= 0){
        maxPlayerId = Math.max(maxPlayerId, 0) + 1;
        p.id = maxPlayerId;
      }
      maxPlayerId = Math.max(maxPlayerId, p.id);
    });
  });
  normalized.playerCounter = Math.max(normalized.playerCounter, maxPlayerId + 1);

  if(!normalized.activeTournamentId || !normalized.tournaments.some(t=>t.id === normalized.activeTournamentId)){
    normalized.activeTournamentId = normalized.tournaments[0].id;
  }

  return normalized;
}

function ensureActiveTournament(){
  if(!Array.isArray(state.tournaments)){
    state.tournaments = [];
  }
  if(state.tournaments.length === 0){
    const firstTournament = createDefaultTournament({id: generateTournamentId(), name: "Tournament 1"});
    state.tournaments.push(firstTournament);
    state.activeTournamentId = firstTournament.id;
  }
  if(!state.tournaments.some(t=>t.id === state.activeTournamentId)){
    state.activeTournamentId = state.tournaments[0].id;
  }
  return state.tournaments.find(t=>t.id === state.activeTournamentId);
}
function currentTournament(){
  return ensureActiveTournament();
}

function renderTournamentSwitcher(){
  const tournament = currentTournament();
  const select = $("tournamentSelect");
  if(select){
    select.innerHTML = state.tournaments.map(t=>`<option value="${t.id}">${t.name}</option>`).join("");
    select.value = String(tournament.id);
  }
  const nameDisplay = $("tournamentNameDisplay");
  if(nameDisplay){
    nameDisplay.textContent = tournament.name ? `‚Äî ${tournament.name}` : "";
  }
  const removeBtn = $("removeTournamentBtn");
  if(removeBtn){
    removeBtn.disabled = state.tournaments.length <= 1;
  }
}

function applyScoringSystemDescription(system){
  const explanation = $("scoringExplanation");
  const percentageExplanation = $("percentageExplanation");
  if(!explanation || !percentageExplanation) return;
  if (system === "simple") {
    explanation.textContent = "Simple: Basic win/loss points. Win +1, Loss -1. Easy to understand but doesn't consider court difficulty.";
    percentageExplanation.innerHTML = "Points % = Points Scored √∑ Total Points in All Games";
  } else if (system === "court") {
    explanation.textContent = "Court Weighted: Higher courts give more points. Court 1=1 pt, Court 2=2 pts, Court 3=3 pts, Court 4=4 pts. Losses do not deduct points.";
    percentageExplanation.innerHTML = "Points % = Points Scored √∑ Total Points in All Games";
  } else if (system === "smart") {
    explanation.textContent = "Smart Points: Considers court difficulty, opponent strength, and margin of victory. Most sophisticated system.";
    percentageExplanation.innerHTML = "Points % = Weighted Points √∑ Total Weighted Points<br>Weighted by: Court difficulty + Opponent strength";
  } else {
    explanation.textContent = "";
    percentageExplanation.innerHTML = "";
  }
}

function toggleHelp(){
  const content = $("helpContent");
  const toggle = $("helpToggle");
  if (content.style.display === "none") {
    content.style.display = "block";
    toggle.textContent = "‚ñ≤";
  } else {
    content.style.display = "none";
    toggle.textContent = "‚ñº";
  }
}

function save(){ Storage.save(state); }
function load(){
  const s = Storage.load();
  if(s){
    state = normalizeStateStructure(s);
  }
  ensureActiveTournament();
}

function playerById(id, tournament = currentTournament()){
  return tournament.players.find(p=>p.id===id);
}

function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

function setLastPartner(id, partnerId, tournament = currentTournament()){
  if(!tournament.lastPartners) tournament.lastPartners = {};
  if(id != null) tournament.lastPartners[id] = partnerId ?? null;
}
function getLastPartner(id, tournament = currentTournament()){
  return tournament.lastPartners?.[id] ?? null;
}
function clearLastPartners(ids, tournament = currentTournament()){
  if(!tournament.lastPartners) tournament.lastPartners = {};
  if(Array.isArray(ids)){
    ids.forEach(playerId => setLastPartner(playerId, null, tournament));
  }else{
    tournament.lastPartners = {};
  }
}

function permute(arr){
  const results = [];
  const used = new Array(arr.length).fill(false);
  const path = [];
  function backtrack(){
    if(path.length === arr.length){
      results.push(path.slice());
      return;
    }
    for(let i=0;i<arr.length;i++){
      if(used[i]) continue;
      used[i]=true;
      path.push(arr[i]);
      backtrack();
      path.pop();
      used[i]=false;
    }
  }
  backtrack();
  return results;
}

function combinations(arr, k){
  const results = [];
  const combo = [];
  function backtrack(start){
    if(combo.length === k){
      results.push(combo.slice());
      return;
    }
    for(let i=start;i<arr.length;i++){
      combo.push(arr[i]);
      backtrack(i+1);
      combo.pop();
    }
  }
  backtrack(0);
  return results;
}

function isPairValid(a, b, tournament = currentTournament()){
  if(a == null || b == null) return true;
  return getLastPartner(a, tournament) !== b && getLastPartner(b, tournament) !== a;
}

function arrangeCourtTeams(courtIds, tournament = currentTournament()){
  if(!Array.isArray(courtIds) || courtIds.length < 4) return courtIds;
  const poolLimit = Math.min(courtIds.length, 6);
  const pool = courtIds.slice(0, poolLimit);

  const comboOfFour = combinations(pool, 4);
  for(const combo of comboOfFour){
    const perms = permute(combo);
    for(const ordering of perms){
      if(isPairValid(ordering[0], ordering[1], tournament) && isPairValid(ordering[2], ordering[3], tournament)){
        const remaining = courtIds.filter(id => !ordering.includes(id));
        return ordering.concat(remaining);
      }
    }
  }

  // Fallback: rotate pairs within first four to try simple swap
  const fallback = courtIds.slice();
  const firstFour = fallback.slice(0,4);
  if(firstFour.length === 4){
    if(!isPairValid(firstFour[0], firstFour[1], tournament) || !isPairValid(firstFour[2], firstFour[3], tournament)){
      const rotated = [firstFour[0], firstFour[2], firstFour[1], firstFour[3]].concat(fallback.slice(4));
      return rotated;
    }
  }
  return courtIds;
}

function randomName(){
  const first = ["Alex","Jordan","Taylor","Morgan","Casey","Riley","Cameron","Drew","Reese","Skyler","Bailey","Avery","Quinn","Rowan","Parker","Hayden","Jesse","Kendall","Logan","Peyton","Sam","Jamie","Blake","Sage","River","Phoenix","Dakota","Finley","Emery","Harper","Charlie","Sage","Indigo","Ocean","Rain","Storm","Sunny","Winter","Autumn","Spring"];
  const last = ["Smith","Johnson","Williams","Brown","Jones","Garcia","Miller","Davis","Rodriguez","Martinez","Hernandez","Lopez","Gonzalez","Wilson","Anderson","Thomas","Taylor","Moore","Jackson","Martin","Lee","Perez","Thompson","White","Harris","Sanchez","Clark","Ramirez","Lewis","Robinson","Walker","Young","Allen","King","Wright","Scott","Torres","Nguyen","Hill","Flores"];
  return first[Math.floor(Math.random()*first.length)] + " " + last[Math.floor(Math.random()*last.length)];
}

function calculateSmartBonuses({courtIndex, scoreA, scoreB, winner, A, B}, tournament = currentTournament()){
  const courtMultiplier = SMART_COURT_WEIGHTS[courtIndex];
  const marginBonus = Math.abs(scoreA - scoreB) / 10;
  const basePoints = 10;

  const opponentSeeds = (winner==="A") ? B : A;
  const playerSeeds = (winner==="A") ? A : B;
  const avgOpponentSeed = opponentSeeds.reduce((sum, id) => {
    const p = playerById(id, tournament);
    return sum + (p ? p.seed : 4.500);
  }, 0) / opponentSeeds.length;
  const avgPlayerSeed = playerSeeds.reduce((sum, id) => {
    const p = playerById(id, tournament);
    return sum + (p ? p.seed : 4.500);
  }, 0) / playerSeeds.length;
  const strengthDiff = (avgOpponentSeed - avgPlayerSeed) / 6.000;
  const strengthBonus = Math.max(0, strengthDiff * 3);

  return {
    courtMultiplier,
    basePoints,
    marginBonus,
    strengthBonus
  };
}

function calculateMatchAwards({system, courtIndex, winner, scoreA, scoreB, A, B}, tournament = currentTournament()){
  const awards = {};
  if(!A || !B) return awards;
  const winners = (winner==="A") ? A : B;
  const losers  = (winner==="A") ? B : A;

  let winPoints = 0;
  let lossPoints = 0;
  if(system === "simple"){
    winPoints = 1;
    lossPoints = -1;
  }else if(system === "court"){
    winPoints = COURT_MULTIPLIERS[courtIndex] ?? 1;
    lossPoints = 0;
  }else if(system === "smart"){
    const {courtMultiplier, basePoints, marginBonus, strengthBonus} = calculateSmartBonuses({courtIndex, scoreA, scoreB, winner, A, B}, tournament);
    winPoints = Math.round((basePoints + marginBonus + strengthBonus) * courtMultiplier);
    lossPoints = Math.round(-2 * courtMultiplier);
  }else{
    winPoints = 1;
    lossPoints = -1;
  }

  winners.forEach(id=>{
    awards[id] = (awards[id] ?? 0) + winPoints;
  });
  losers.forEach(id=>{
    awards[id] = (awards[id] ?? 0) + lossPoints;
  });
  return awards;
}

function applyAwards(awards, tournament = currentTournament()){
  if(!awards) return;
  Object.entries(awards).forEach(([idStr, delta])=>{
    const id = Number(idStr);
    const p = playerById(id, tournament);
    if(!p) return;
    const next = (p.points ?? 0) + delta;
    p.points = Math.max(0, Math.round(next * 1000) / 1000);
  });
}

function recalculatePointsFromMatches(tournament = currentTournament()){
  tournament.players.forEach(p=>p.points = 0);
  if(!Array.isArray(tournament.matches)) return;
  const ordered = tournament.matches.slice().sort((a,b)=>(a.ts||0)-(b.ts||0));
  ordered.forEach(match=>{
    const system = match.system || tournament.scoringSystem || "simple";
    const courtIndex = (match.court || 1) - 1;
    let awards = match.awards;
    if(!awards || typeof awards !== "object"){
      awards = calculateMatchAwards({
        system,
        courtIndex,
        winner: match.winner,
        scoreA: match.scoreA,
        scoreB: match.scoreB,
        A: match.A,
        B: match.B
      }, tournament);
      match.awards = awards;
    }
    applyAwards(awards, tournament);
  });
  tournament.matchesPlayed = ordered.length;
}

/* ---------- Rendering ---------- */
function renderPlayers(){
  const tournament = currentTournament();
  const list = $("playerList");
  list.innerHTML = "";
  const sorted = clone(tournament.players).sort((a,b)=>b.seed - a.seed || a.name.localeCompare(b.name));
  for(const p of sorted){
    const row = document.createElement("div");
    row.className = "player";
    row.innerHTML = `
      <span>${p.name}</span>
      <span class="row">
        <span class="tag mono" title="DUPR Rating">${p.seed.toFixed(3)}</span>
        <span class="tag green mono" title="League points">${p.points ?? 0} pts</span>
        <button class="btn" data-act="seedPlus" data-id="${p.id}" title="Increase seed">Seed +</button>
        <button class="btn" data-act="seedMinus" data-id="${p.id}" title="Decrease seed">Seed ‚àí</button>
        <button class="btn warn" data-act="remove" data-id="${p.id}">Remove</button>
      </span>
    `;
    list.appendChild(row);
  }
  $("playerCount").textContent = tournament.players.length;

  const sel = $("playerFilter");
  const selected = sel.value;
  sel.innerHTML = `<option value="">Filter by player‚Ä¶</option>` + sorted.map(p=>`<option value="${p.id}">${p.name}</option>`).join("");
  if([...sel.options].some(o=>o.value===selected)) sel.value = selected;
}

function courtEntryHTML(idx, A, B){
  return `
    <div class="teams">
      <div class="team">${slotHTML(A[0])}${slotHTML(A[1])}</div>
      <div class="vs">VS</div>
      <div class="team">${slotHTML(B[0])}${slotHTML(B[1])}</div>
    </div>
    <div class="row">
      <input type="text" inputmode="numeric" pattern="[0-9\\-:x ]*" placeholder="Score e.g., 11-7" id="score-${idx}" style="width:140px">
      <span class="muted">Enter score for this court</span>
    </div>
  `;
}
function slotHTML(p){
  if(!p) return `<div class="slot"><span class="muted">Empty</span><span class="tag">‚Äî</span></div>`;
  return `<div class="slot"><span>${p.name}</span><span class="tag mono">${p.points ?? 0} pts</span></div>`;
}
function renderCourts(){
  const tournament = currentTournament();
  const wrap = $("courts");
  wrap.innerHTML = "";
  tournament.courts.forEach((court, idx)=>{
    const div = document.createElement("div");
    div.className = "court";
    const courtNo = idx+1;
    const title = `Court ${courtNo} ${courtNo===4?"(Highest)":courtNo===1?"(Lowest)":""}`;
    const players = court.map(id => playerById(id, tournament)).filter(Boolean);
    const A = players.slice(0,2);
    const B = players.slice(2,4);
    div.innerHTML = `
      <header>
        <strong>${title}</strong>
        <span class="muted">On court: ${court.length}</span>
      </header>
      <div class="body">
        ${courtEntryHTML(idx, A, B)}
      </div>
    `;
    wrap.appendChild(div);
  });
}

function renderLeagueMeta(){
  const tournament = currentTournament();
  $("played").textContent = tournament.matchesPlayed;
  $("limit").textContent = tournament.matchLimit ?? "‚Äî";
  const limit = tournament.matchLimit ?? 0;
  const pct = (limit>0) ? Math.min(100, Math.round(100*tournament.matchesPlayed/limit)) : 0;
  $("bar").style.width = pct + "%";
  const disable = (tournament.matchLimit && tournament.matchesPlayed >= tournament.matchLimit);
  document.querySelectorAll('button[data-submit="score"]').forEach(b=>b.disabled = disable);
  $("leaderboardCard").style.display = disable ? "block" : "none";
  if(disable) renderLeaderboard();
}

function renderLeaderboard(){
  const tournament = currentTournament();
  const tbody = document.querySelector("#leaderboardTable tbody");
  tbody.innerHTML = "";
  const ranked = clone(tournament.players).sort((a,b)=> (b.points??0) - (a.points??0) || a.name.localeCompare(b.name));
  ranked.forEach((p, i)=>{
    const tr = document.createElement("tr");
    if(i === 0) tr.classList.add("points-leader");
    tr.innerHTML = `<td class="mono">${i+1}</td><td>${p.name}</td><td class="mono">${p.points ?? 0}</td><td class="mono">${p.seed.toFixed(3)}</td>`;
    tbody.appendChild(tr);
  });
}

function computeSummary(){
  const tournament = currentTournament();
  const summary = tournament.players.map(p=>({id:p.id, name:p.name, points:p.points||0, wins:0, losses:0, pointsScored:0, pointsAllowed:0, weightedPoints:0, totalWeight:0}));
  const byId = Object.fromEntries(summary.map(s=>[s.id,s]));
  const scoringSystem = tournament.scoringSystem || "simple";
  
  for(const m of tournament.matches){
    if(m.A.length===2 && m.B.length===2){
      const winA = (m.winner==="A");
      const scoreA = m.scoreA || 0;
      const scoreB = m.scoreB || 0;
      const totalPoints = scoreA + scoreB;
      const courtIndex = m.court - 1;
      
      // Update wins/losses
      for(const id of m.A){ 
        if(byId[id]) {
          if(winA) byId[id].wins++; 
          else byId[id].losses++;
        }
      }
      for(const id of m.B){ 
        if(byId[id]) {
          if(winA) byId[id].losses++; 
          else byId[id].wins++;
        }
      }
      
      // Update points scored/allowed
      for(const id of m.A){ 
        if(byId[id]) {
          byId[id].pointsScored += scoreA;
          byId[id].pointsAllowed += scoreB;
        }
      }
      for(const id of m.B){ 
        if(byId[id]) {
          byId[id].pointsScored += scoreB;
          byId[id].pointsAllowed += scoreA;
        }
      }
      
      // Calculate weighted points based on scoring system
      if (scoringSystem === "smart") {
        const courtWeight = SMART_COURT_WEIGHTS[courtIndex];
        const teamA = m.A.map(id => playerById(id, tournament)).filter(Boolean);
        const teamB = m.B.map(id => playerById(id, tournament)).filter(Boolean);
        const avgSeedA = teamA.reduce((sum, p) => sum + p.seed, 0) / teamA.length;
        const avgSeedB = teamB.reduce((sum, p) => sum + p.seed, 0) / teamB.length;
        
        for(const id of m.A){ 
          if(byId[id]) {
            // Normalize DUPR score (2.000-8.000) to 0.2-0.8 range for weighting
            const opponentStrength = (avgSeedB - 2.000) / 6.000 + 0.2;
            byId[id].weightedPoints += scoreA * courtWeight * opponentStrength;
            byId[id].totalWeight += totalPoints * courtWeight * opponentStrength;
          }
        }
        for(const id of m.B){ 
          if(byId[id]) {
            // Normalize DUPR score (2.000-8.000) to 0.2-0.8 range for weighting
            const opponentStrength = (avgSeedA - 2.000) / 6.000 + 0.2;
            byId[id].weightedPoints += scoreB * courtWeight * opponentStrength;
            byId[id].totalWeight += totalPoints * courtWeight * opponentStrength;
          }
        }
      } else {
        // For simple and court systems, use basic points percentage
        for(const id of m.A){ 
          if(byId[id]) {
            byId[id].weightedPoints += scoreA;
            byId[id].totalWeight += totalPoints;
          }
        }
        for(const id of m.B){ 
          if(byId[id]) {
            byId[id].weightedPoints += scoreB;
            byId[id].totalWeight += totalPoints;
          }
        }
      }
    }
  }
  
  summary.forEach(s=>{ 
    s.total = s.wins + s.losses; 
    s.totalPoints = s.pointsScored + s.pointsAllowed;
    s.winPct = s.totalWeight > 0 ? Math.round(1000*s.weightedPoints/s.totalWeight)/10 : 0; 
  });
  summary.sort((a,b)=> b.points - a.points || b.winPct - a.winPct || a.name.localeCompare(b.name));
  return summary;
}
function updateLeaderHighlights(summaryData){
  const containers = [
    document.getElementById("leaderHighlights"),
    document.getElementById("leaderboardHighlights")
  ];
  const hasContainers = containers.some(el => el);
  if(!hasContainers) return {pointsLeaderId: null, pctLeaderId: null};

  if(!summaryData.length){
    containers.forEach(el=>{
      if(el) el.innerHTML = `<span class="chip muted">Add players and record matches to crown leaders.</span>`;
    });
    return {pointsLeaderId: null, pctLeaderId: null};
  }

  const pointsLeader = summaryData[0];
  let pctLeader = summaryData[0];
  summaryData.forEach(entry=>{
    if(entry.winPct > (pctLeader?.winPct ?? -Infinity)){
      pctLeader = entry;
    }
  });

  const pointsName = pointsLeader.name;
  const pointsScore = pointsLeader.points ?? 0;
  const pctName = pctLeader?.name ?? pointsName;
  const pctScore = pctLeader?.winPct ?? pointsLeader.winPct;

  let highlightHTML;
  if(pointsLeader.id === (pctLeader?.id ?? null)){
    highlightHTML = `<span class="chip active">Overall Leader: ${pointsName} (${pointsScore} pts ¬∑ ${pctScore}% points)</span>`;
  }else{
    highlightHTML = `<span class="chip active">Points Leader: ${pointsName} (${pointsScore} pts)</span>` +
      `<span class="chip leader-secondary">Points % Leader: ${pctName} (${pctScore}%)</span>`;
  }

  containers.forEach(el=>{
    if(el) el.innerHTML = highlightHTML;
  });

  return {pointsLeaderId: pointsLeader.id, pctLeaderId: pctLeader?.id ?? null};
}
function renderSummary(){
  const tbody = document.querySelector("#summaryTable tbody");
  tbody.innerHTML = "";
  const data = computeSummary();
  const {pointsLeaderId, pctLeaderId} = updateLeaderHighlights(data);
  data.forEach((s,i)=>{
    const tr = document.createElement("tr");
    if(s.id === pointsLeaderId) tr.classList.add("points-leader");
    if(s.id === pctLeaderId) tr.classList.add("pct-leader");
    tr.innerHTML = `<td class="mono">${i+1}</td><td>${s.name}</td><td class="mono">${s.wins}</td><td class="mono">${s.losses}</td><td class="mono">${s.winPct}%</td><td class="mono">${s.points}</td>`;
    tbody.appendChild(tr);
  });
}

function renderHistory(){
  const tournament = currentTournament();
  const tbody = document.querySelector("#historyTable tbody");
  tbody.innerHTML = "";
  const filterChip = document.querySelector(".chip.active")?.dataset.filter || "all";
  const playerSel = $("playerFilter").value;
  let rows = tournament.matches.slice().reverse();
  if(filterChip.startsWith("court")){
    const n = Number(filterChip.replace("court",""));
    rows = rows.filter(m => m.court === n);
  }
  if(playerSel){
    const pid = Number(playerSel);
    rows = rows.filter(m => m.A.includes(pid) || m.B.includes(pid));
  }
  const fmt = (ts)=>{
    const d = new Date(ts);
    const pad=(x)=>String(x).padStart(2,'0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  };
  for(const m of rows){
    const namesA = m.A.map(id => playerById(id, tournament)?.name || `#${id}`).join(", ");
    const namesB = m.B.map(id => playerById(id, tournament)?.name || `#${id}`).join(", ");
    const totalScore = (Number(m.scoreA) || 0) + (Number(m.scoreB) || 0);
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td class="mono nowrap">${fmt(m.ts)}</td>
      <td>Court ${m.court}</td>
      <td>${namesA}</td>
      <td>${namesB}</td>
      <td class="mono">${m.scoreA}-${m.scoreB}</td>
      <td class="mono">${totalScore}</td>
      <td>${m.winner==="A"?"Team A":"Team B"}</td>
    `;
    tbody.appendChild(tr);
  }
}

function rerender(){
  if(Array.isArray(state.tournaments)){
    state.tournaments.forEach(t => recalculatePointsFromMatches(t));
  }
  const tournament = currentTournament();
  const scoringSelect = document.getElementById("scoringSystem");
  if(scoringSelect){
    scoringSelect.value = tournament.scoringSystem || "simple";
    applyScoringSystemDescription(scoringSelect.value);
  }
  renderTournamentSwitcher();
  renderPlayers();
  renderCourts();
  renderLeagueMeta();
  renderLeaderboard();
  renderSummary();
  renderHistory();
  save();
}

/* ---------- Core ops ---------- */
function addTournament(){
  const defaultName = generateTournamentName();
  const providedName = prompt("Tournament name?", defaultName);
  const name = (providedName && providedName.trim()) ? providedName.trim() : defaultName;
  const reference = currentTournament();
  const newTournament = createDefaultTournament({
    id: generateTournamentId(),
    name,
    scoringSystem: reference?.scoringSystem || "court"
  });
  state.tournaments.push(newTournament);
  state.activeTournamentId = newTournament.id;
  rerender();
}

function removeTournament(){
  if(state.tournaments.length <= 1){
    alert("At least one tournament must remain.");
    return;
  }
  const tournament = currentTournament();
  if(!confirm(`Remove "${tournament.name}"? This cannot be undone.`)) return;
  state.tournaments = state.tournaments.filter(t=>t.id !== tournament.id);
  ensureActiveTournament();
  rerender();
}

function addPlayer(name, seed, options={}){
  const tournament = currentTournament();
  name = (name||"").trim();
  if(!name) return;
  const s = Number(seed);
  // DUPR scores: 2.000 to 8.000 with 3 decimal places
  let duprScore = Number.isFinite(s) ? Math.max(2.000, Math.min(8.000, Math.round(s * 1000) / 1000)) : 4.500;
  const p = {id: generatePlayerId(), name, seed: duprScore, points: 0};
  tournament.players.push(p);
  if(!options.silent){
    rerender();
  }
  return p;
}
function addRandomPlayer(options={}){
  const n = randomName();
  // Generate realistic DUPR score distribution
  // Most players fall in the 3.000-6.000 range with some outliers
  let seed;
  const rand = Math.random();
  
  if (rand < 0.05) {
    // 5% chance for elite players (6.000-8.000)
    seed = 6.000 + Math.random() * 2.000;
  } else if (rand < 0.25) {
    // 20% chance for advanced players (4.500-6.000)
    seed = 4.500 + Math.random() * 1.500;
  } else if (rand < 0.70) {
    // 45% chance for intermediate players (3.000-4.500)
    seed = 3.000 + Math.random() * 1.500;
  } else {
    // 30% chance for beginner players (2.000-3.000)
    seed = 2.000 + Math.random() * 1.000;
  }
  
  // Round to 3 decimal places
  seed = Math.round(seed * 1000) / 1000;
  return addPlayer(n, seed, options);
}

function addRandomPlayers(count){
  const total = Number(count);
  if(!Number.isFinite(total) || total <= 0) return;
  for(let i=0;i<total;i++){
    addRandomPlayer({silent:true});
  }
  rerender();
}

function removePlayer(id){
  const tournament = currentTournament();
  tournament.players = tournament.players.filter(p=>p.id!==id);
  tournament.courts = tournament.courts.map(c=>c.filter(pid=>pid!==id));
  if(tournament.lastPartners){
    delete tournament.lastPartners[id];
    Object.keys(tournament.lastPartners).forEach(pid=>{
      if(tournament.lastPartners[pid] === id) tournament.lastPartners[pid] = null;
    });
  }
  rerender();
}

function setMatchLimit(n){
  const v = Number(n);
  const tournament = currentTournament();
  tournament.matchLimit = Number.isFinite(v) && v>0 ? Math.round(v) : null;
  rerender();
}

function initialSeedCourts(){
  const tournament = currentTournament();
  const sorted = clone(tournament.players).sort((a,b)=>b.seed - a.seed || a.name.localeCompare(b.name));
  const totalPlayers = sorted.length;
  
  // Initialize empty courts
  const c1=[],c2=[],c3=[],c4=[];
  
  // Handle different group sizes with flexible distribution
  if (totalPlayers <= 4) {
    // 1-4 players: All on Court 4, balanced teams
    const players = sorted.slice(0, 4);
    c4.push(...players.map(p => p.id));
  } else if (totalPlayers <= 8) {
    // 5-8 players: Distribute across 2 courts (3&4)
    const topHalf = sorted.slice(0, Math.ceil(totalPlayers/2));
    const bottomHalf = sorted.slice(Math.ceil(totalPlayers/2));
    
    // Court 4: Top half
    c4.push(...topHalf.map(p => p.id));
    // Court 3: Bottom half
    c3.push(...bottomHalf.map(p => p.id));
  } else if (totalPlayers <= 12) {
    // 9-12 players: Distribute across 3 courts (2,3,4)
    const third = Math.ceil(totalPlayers/3);
    const topThird = sorted.slice(0, third);
    const midThird = sorted.slice(third, third * 2);
    const bottomThird = sorted.slice(third * 2);
    
    c4.push(...topThird.map(p => p.id));
    c3.push(...midThird.map(p => p.id));
    c2.push(...bottomThird.map(p => p.id));
  } else {
    // 13+ players: Use all 4 courts with skill-based distribution
    const quarter = Math.ceil(totalPlayers/4);
    const topQuarter = sorted.slice(0, quarter);
    const upperMid = sorted.slice(quarter, quarter * 2);
    const lowerMid = sorted.slice(quarter * 2, quarter * 3);
    const bottomQuarter = sorted.slice(quarter * 3);
    
    c4.push(...topQuarter.map(p => p.id));
    c3.push(...upperMid.map(p => p.id));
    c2.push(...lowerMid.map(p => p.id));
    c1.push(...bottomQuarter.map(p => p.id));
  }
  
  // Balance teams within each court (avoid stacking)
  const balanceTeams = (court) => {
    if (court.length < 4) return court;
    const players = court.map(id => playerById(id, tournament)).filter(Boolean);
    players.sort((a,b) => b.seed - a.seed);
    // Alternate high/low seeds for balanced teams
    return [players[0], players[3], players[1], players[2]].map(p => p.id);
  };
  
  tournament.courts = [
    balanceTeams(c1), 
    balanceTeams(c2), 
    balanceTeams(c3), 
    balanceTeams(c4)
  ].map(court => arrangeCourtTeams(court, tournament));
  
  tournament.matchesPlayed = 0;
  tournament.players.forEach(p=>p.points=0);
  tournament.matches = [];
  tournament.tournamentStarted = true;
  clearLastPartners(undefined, tournament);
  rerender();
}

function gradualSeedCourts(){
  const tournament = currentTournament();
  const sorted = clone(tournament.players).sort((a,b)=>b.seed - a.seed || a.name.localeCompare(b.name));
  
  // Start with only top 8 players (2 courts)
  const top8 = sorted.slice(0, 8);
  const remaining = sorted.slice(8);
  
  // Place top 8 on Courts 3 and 4 (highest courts)
  const c1=[],c2=[],c3=[],c4=[];
  
  // Court 4: Top 4 players
  const court4Players = top8.slice(0, 4);
  c4.push(...court4Players.map(p => p.id));
  
  // Court 3: Next 4 players  
  const court3Players = top8.slice(4, 8);
  c3.push(...court3Players.map(p => p.id));
  
  // Courts 1 & 2: Remaining players (if any)
  const court2Players = remaining.slice(0, 4);
  const court1Players = remaining.slice(4, 8);
  c2.push(...court2Players.map(p => p.id));
  c1.push(...court1Players.map(p => p.id));
  
  // Balance teams within each court
  const balanceTeams = (court) => {
    if (court.length < 4) return court;
    const players = court.map(id => playerById(id, tournament)).filter(Boolean);
    players.sort((a,b) => b.seed - a.seed);
    return [players[0], players[3], players[1], players[2]].map(p => p.id);
  };
  
  tournament.courts = [
    balanceTeams(c1), 
    balanceTeams(c2), 
    balanceTeams(c3), 
    balanceTeams(c4)
  ].map(court => arrangeCourtTeams(court, tournament));
  
  tournament.matchesPlayed = 0;
  tournament.players.forEach(p=>p.points=0);
  tournament.matches = [];
  tournament.tournamentStarted = true;
  clearLastPartners(undefined, tournament);
  rerender();
  
  // Show info about gradual start
  if (remaining.length > 0) {
    alert(`Gradual Start: Top 8 players on Courts 3-4. ${remaining.length} players will join as others are eliminated or after initial matches.`);
  }
}

function classicSeedCourts(){
  // Original simple seeding: top 4 on court 4, next 4 on court 3, etc.
  const tournament = currentTournament();
  const sorted = clone(tournament.players).sort((a,b)=>b.seed - a.seed || a.name.localeCompare(b.name));
  const c1=[],c2=[],c3=[],c4=[];
  sorted.forEach((p,i)=>{
    if(i<4) c4.push(p.id);
    else if(i<8) c3.push(p.id);
    else if(i<12) c2.push(p.id);
    else c1.push(p.id);
  });
  tournament.courts=[shuffle(c1),shuffle(c2),shuffle(c3),shuffle(c4)].map(court => arrangeCourtTeams(court, tournament));
  tournament.matchesPlayed = 0;
  tournament.players.forEach(p=>p.points=0);
  tournament.matches = [];
  tournament.tournamentStarted = true;
  clearLastPartners(undefined, tournament);
  rerender();
}

function shufflePairsSameCourt(){
  const tournament = currentTournament();
  tournament.courts = tournament.courts.map(c=>arrangeCourtTeams(shuffle(c), tournament));
  rerender();
}

/* ---------- Input parsing & result handling ---------- */
function parseScore(input){
  if(!input) return null;
  const m = String(input).trim().match(/^(\d+)\s*[-:x]\s*(\d+)$/i);
  if(!m) return null;
  return {a: Number(m[1]), b: Number(m[2])};
}

function submitRound(){
  const tournament = currentTournament();
  if(tournament.matchLimit && tournament.matchesPlayed >= tournament.matchLimit) return;

  // Collect all scores and validate
  const roundResults = [];
  let hasValidScores = false;
  let hasInvalidScores = false;
  let errorMessages = [];

  for(let courtIndex = 0; courtIndex < 4; courtIndex++){
    const court = tournament.courts[courtIndex] || [];
    const A = court.slice(0,2);
    const B = court.slice(2,4);
    
    // Skip empty courts
    if(A.length < 2 || B.length < 2) continue;
    
    const input = document.getElementById(`score-${courtIndex}`).value;
    const parsed = parseScore(input);
    
    if(!parsed){
      hasInvalidScores = true;
      errorMessages.push(`Court ${courtIndex + 1}: Invalid score format`);
      continue;
    }
    
    const scoreA = parsed.a, scoreB = parsed.b;
    if(scoreA === scoreB){
      hasInvalidScores = true;
      errorMessages.push(`Court ${courtIndex + 1}: Ties not supported`);
      continue;
    }
    
    const winner = (scoreA > scoreB) ? "A" : "B";
    roundResults.push({courtIndex, winner, scoreA, scoreB, A, B});
    hasValidScores = true;
  }

  // Show errors if any
  if(hasInvalidScores){
    alert("Please fix these errors:\n" + errorMessages.join("\n"));
    return;
  }

  // Check if we have any valid matches to process
  if(!hasValidScores){
    alert("No valid matches to submit. Please enter scores for courts with 4 players.");
    return;
  }

  // Process all valid matches in the round
  roundResults.forEach(result => {
    applyResult(result.courtIndex, result.winner, result.scoreA, result.scoreB, tournament);
  });

  // Process court movements after all matches are complete
  processRoundResults(tournament);

  // Clear all score inputs
  for(let i = 0; i < 4; i++){
    const input = document.getElementById(`score-${i}`);
    if(input) input.value = "";
  }

  // Update the display
  rerender();
}

function applyResult(courtIndex, winner, scoreA, scoreB, tournament = currentTournament()){
  const court = tournament.courts[courtIndex] || [];
  const A = court.slice(0,2);
  const B = court.slice(2,4);

  const winners = (winner==="A") ? A : B;
  const losers  = (winner==="A") ? B : A;

  if(winners.length === 2){
    setLastPartner(winners[0], winners[1], tournament);
    setLastPartner(winners[1], winners[0], tournament);
  }
  if(losers.length === 2){
    setLastPartner(losers[0], losers[1], tournament);
    setLastPartner(losers[1], losers[0], tournament);
  }

  const scoringSystem = tournament.scoringSystem || "simple";
  const awards = calculateMatchAwards({
    system: scoringSystem,
    courtIndex,
    winner,
    scoreA,
    scoreB,
    A,
    B
  }, tournament);
  applyAwards(awards, tournament);

  tournament.matches.push({
    ts: Date.now(),
    court: courtIndex+1,
    A: A.slice(),
    B: B.slice(),
    winner: winner,
    scoreA: scoreA,
    scoreB: scoreB,
    system: scoringSystem,
    awards
  });

}

function processRoundResults(tournament = currentTournament()){
  const incomingWinners = [[],[],[],[]];
  const incomingLosers = [[],[],[],[]];
  const stayingPlayers = tournament.courts.map(c => c.slice());
  const reversedMatches = tournament.matches.slice().reverse();

  for(let courtIndex = 0; courtIndex < 4; courtIndex++){
    const court = tournament.courts[courtIndex] || [];
    if(court.length < 4) continue;

    const recentMatch = reversedMatches.find(m => m.court === courtIndex + 1);
    if(!recentMatch) continue;

    const matchPlayers = [...recentMatch.A, ...recentMatch.B];
    stayingPlayers[courtIndex] = stayingPlayers[courtIndex].filter(id => !matchPlayers.includes(id));

    const winners = (recentMatch.winner === "A") ? recentMatch.A.slice() : recentMatch.B.slice();
    const losers = (recentMatch.winner === "A") ? recentMatch.B.slice() : recentMatch.A.slice();

    const upTarget = courtIndex < 3 ? courtIndex + 1 : courtIndex;
    const downTarget = courtIndex > 0 ? courtIndex - 1 : courtIndex;

    if(upTarget === courtIndex){
      incomingWinners[courtIndex].push(...winners);
    }else{
      incomingWinners[upTarget].push(...winners);
    }

    if(downTarget === courtIndex){
      incomingLosers[courtIndex].push(...losers);
    }else{
      incomingLosers[downTarget].push(...losers);
    }
  }

  const nextCourts = [[],[],[],[]];
  for(let i=0;i<4;i++){
    nextCourts[i] = [
      ...incomingWinners[i],
      ...stayingPlayers[i],
      ...incomingLosers[i]
    ];
  }

  tournament.courts = nextCourts.map(court => arrangeCourtTeams(court, tournament));
  tournament.tournamentStarted = true;
}

/* ---------- Export / Import ---------- */
function exportState(){
  ensureActiveTournament();
  const blob = new Blob([JSON.stringify(state,null,2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "pickleball_league_state.json";
  a.click();
  setTimeout(()=>URL.revokeObjectURL(url), 400);
}
function importState(file){
  const reader = new FileReader();
  reader.onload = e=>{
    try{
      const data = JSON.parse(e.target.result);
      if(!data || typeof data !== "object") throw new Error("Invalid file");
      state = normalizeStateStructure(data);
      ensureActiveTournament();
      rerender();
    }catch(err){
      alert("Import failed: " + err.message);
    }
  };
  reader.readAsText(file);
}

/* ---------- Events ---------- */
document.addEventListener("click", (e)=>{
  const t = e.target;
  if(t.id==="addPlayerBtn"){
    addPlayer(document.getElementById("name").value, document.getElementById("rating").value);
    document.getElementById("name").value=""; document.getElementById("rating").value="";
  }
  if(t.id==="addRandomBtn"){ addRandomPlayer(); }
  if(t.id==="addRandom16Btn"){ addRandomPlayers(16); }
  if(t.id==="addTournamentBtn"){ addTournament(); }
  if(t.id==="removeTournamentBtn"){ removeTournament(); }
  if(t.id==="seedBtn"){ initialSeedCourts(); }
  if(t.id==="gradualSeedBtn"){ gradualSeedCourts(); }
  if(t.id==="classicSeedBtn"){ classicSeedCourts(); }
  if(t.id==="shufflePairsBtn"){ shufflePairsSameCourt(); }
  if(t.id==="applyLimitBtn"){ setMatchLimit(document.getElementById("matchLimit").value); }
  if(t.id==="newLeagueBtn"){
    if(confirm("Start a new league? This resets points and match count (players & seeding stay the same).")){
      const tournament = currentTournament();
      tournament.players.forEach(p=>p.points=0);
      tournament.matchesPlayed = 0;
      tournament.matches = [];
      tournament.tournamentStarted = false;
      clearLastPartners(undefined, tournament);
      rerender();
    }
  }
  if(t.id==="resetBtn"){
    if(confirm("Reset the entire app? This clears saved data (players, courts, league, history).")){
      Storage.clear();
      state = createDefaultState();
      ensureActiveTournament();
      rerender();
    }
  }
  if(t.id==="exportBtn"){ exportState(); }
  if(t.dataset && t.dataset.act==="remove"){
    removePlayer(Number(t.dataset.id));
  }
  if(t.dataset && t.dataset.act==="seedPlus"){
    const p = playerById(Number(t.dataset.id)); 
    if(p){ 
      p.seed = Math.min(8.000, (p.seed||4.500) + 0.100); // Increase by 0.100 DUPR points
      rerender(); 
    }
  }
  if(t.dataset && t.dataset.act==="seedMinus"){
    const p = playerById(Number(t.dataset.id)); 
    if(p){ 
      p.seed = Math.max(2.000, (p.seed||4.500) - 0.100); // Decrease by 0.100 DUPR points
      rerender(); 
    }
  }
  if(t.id==="submitRoundBtn"){
    submitRound();
  }
  if(t.classList.contains("chip")){
    document.querySelectorAll(".chip").forEach(c=>c.classList.remove("active"));
    t.classList.add("active");
    renderHistory();
  }
  if(t.id==="clearHistoryBtn"){
    if(confirm("Clear all match history? This cannot be undone.")){
      const tournament = currentTournament();
      tournament.matches = [];
      rerender();
    }
  }
});

document.getElementById("playerFilter").addEventListener("change", ()=>{ renderHistory(); });
document.getElementById("tournamentSelect").addEventListener("change", (event)=>{
  const selectedId = Number(event.target.value);
  if(Number.isFinite(selectedId)){
    state.activeTournamentId = selectedId;
    ensureActiveTournament();
    rerender();
  }
});
document.getElementById("importFile").addEventListener("change", (event)=>{
  const fileInput = event.target;
  const file = fileInput?.files?.[0];
  if(file){
    importState(file);
    fileInput.value = "";
  }
});

document.getElementById("scoringSystem").addEventListener("change", ()=>{
  const system = document.getElementById("scoringSystem").value;
  const tournament = currentTournament();
  tournament.scoringSystem = system;
  applyScoringSystemDescription(system);
  // Recalculate summary with new system
  rerender();
});

/* ---------- Init ---------- */
load();
rerender();
</script>
</body>
</html>
